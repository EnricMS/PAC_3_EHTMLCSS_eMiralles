"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.endsWithAny = exports.writeToJsonFile = exports.shouldElementBeIgnored = exports.getEscaped = exports.waitForHTML = exports.success = exports.log = exports.error = exports.debug = exports.isAbsoluteUrl = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
function isAbsoluteUrl(url) {
    return /^(?:[a-z]+:)?\/\//i.test(url);
}
exports.isAbsoluteUrl = isAbsoluteUrl;
function debug(debugMode = false, message, ...optionalParams) {
    if (debugMode) {
        console.debug(chalk_1.default.yellow(message, optionalParams));
    }
}
exports.debug = debug;
function error(message, ...optionalParams) {
    console.error(chalk_1.default.red(message, optionalParams));
}
exports.error = error;
function log(message, ...optionalParams) {
    console.info(chalk_1.default.blue(message, optionalParams));
}
exports.log = log;
function success(message, ...optionalParams) {
    console.info(chalk_1.default.green(message, optionalParams));
}
exports.success = success;
async function waitForHTML(page, timeout = 30000, debugMode = false) {
    const checkDurationMsecs = 1000;
    const maxChecks = timeout / checkDurationMsecs;
    let lastHTMLSize = 0;
    let checkCounts = 1;
    let countStableSizeIterations = 0;
    const minStableSizeIterations = 2;
    while (checkCounts++ <= maxChecks) {
        const html = await page.content();
        const currentHTMLSize = html.length;
        const bodyHTMLSize = await page.evaluate(() => document.body?.innerHTML?.length);
        debug(debugMode, 'last: ', lastHTMLSize, ' <> curr: ', currentHTMLSize, ' body html size: ', bodyHTMLSize);
        if (lastHTMLSize && bodyHTMLSize && lastHTMLSize != 0 && currentHTMLSize == lastHTMLSize)
            countStableSizeIterations++;
        else
            countStableSizeIterations = 0;
        if (countStableSizeIterations >= minStableSizeIterations) {
            log('Page rendered fully..');
            break;
        }
        lastHTMLSize = currentHTMLSize;
        await page.waitForTimeout(checkDurationMsecs);
    }
}
exports.waitForHTML = waitForHTML;
function getEscaped(link) {
    return link.replace(/[`~ !@#$%^&*()_|+\-=?;:'",.<>{}\\[\]/]/gi, '_').replace(/\n/g, '');
}
exports.getEscaped = getEscaped;
function shouldElementBeIgnored(element, elementstoIgnore) {
    if (!elementstoIgnore)
        return false;
    let shouldElementBeIgnored = false;
    for (let i = 0; i < element.attributes.length; i++) {
        shouldElementBeIgnored = elementstoIgnore.some((e) => element.attributes.item(i)?.nodeValue?.includes(e));
        if (shouldElementBeIgnored)
            break;
    }
    return shouldElementBeIgnored;
}
exports.shouldElementBeIgnored = shouldElementBeIgnored;
function writeToJsonFile(data, path, vp) {
    log(chalk_1.default.blue('#############################################################################################'));
    log(chalk_1.default.blue(`Writing results to ${path}/results_${vp.width}_${vp.height}'.json`));
    log(chalk_1.default.blue('#############################################################################################'));
    if (!fs_1.default.existsSync(path)) {
        fs_1.default.mkdirSync(path, { recursive: true });
    }
    fs_1.default.writeFileSync(path + '/results_' + vp.width + '_' + vp.height + '.json', data);
}
exports.writeToJsonFile = writeToJsonFile;
function endsWithAny(array, toCheck) {
    return array.some((suffix) => {
        return toCheck.endsWith(suffix);
    });
}
exports.endsWithAny = endsWithAny;
