"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeScreenshotsWithErrorsBorderd = void 0;
const helper_functions_1 = require("./helper-functions");
const uuid_1 = require("uuid");
const expose_deep_js_1 = require("./expose-deep-js");
const is_element_visible_1 = require("./is-element-visible");
const helper_saving_screenshots_1 = require("./helper-saving-screenshots");
const uniqueNamePerUrl = new Map();
async function makeScreenshotsWithErrorsBorderd(resultByUrl, page, config, savedScreenshotHtmls) {
    let currentMapObject = uniqueNamePerUrl.get(resultByUrl.url);
    if (!currentMapObject) {
        uniqueNamePerUrl.set(resultByUrl.url, { id: (0, uuid_1.v4)(), count: 0 });
        currentMapObject = uniqueNamePerUrl.get(resultByUrl.url);
    }
    (0, helper_functions_1.debug)(config.debugMode, 'make screenshots with border for ' + page.url());
    try {
        await page.exposeFunction('debug', helper_functions_1.debug);
    }
    catch (e) {
        if (config.debugMode) {
            (0, helper_functions_1.error)(e.message + '. Ignored because normally it means that function already exposed');
        }
    }
    await page.evaluate((0, expose_deep_js_1.exposeDepsJs)({ isElementVisible: is_element_visible_1.isElementVisible }));
    await page.evaluate((0, expose_deep_js_1.exposeDepsJs)({ highestZIndex: is_element_visible_1.highestZIndex }));
    await page.evaluate((0, expose_deep_js_1.exposeDepsJs)({ elementIntersected: is_element_visible_1.elementIntersected }));
    for (const result of resultByUrl.violations) {
        for (const node of result.nodes) {
            const alreadyScreenshotedImage = savedScreenshotHtmls.get(node.html);
            if (alreadyScreenshotedImage === undefined && currentMapObject) {
                const image = currentMapObject.id + '_' + currentMapObject.count + '.png';
                const screenshotResult = await (0, helper_saving_screenshots_1.saveScreenshotSingleDomElement)(page, config.imagesPath, image, config.saveImages, node.target[0], 10, config.debugMode);
                if (typeof screenshotResult === 'boolean' && screenshotResult === true) {
                    node.image = image;
                    savedScreenshotHtmls.set(node.html, image);
                    currentMapObject.count++;
                }
                else if (typeof screenshotResult === 'string') {
                    node.image = screenshotResult;
                    savedScreenshotHtmls.set(node.html, screenshotResult);
                    currentMapObject.count++;
                }
                else {
                    savedScreenshotHtmls.set(node.html, null);
                }
            }
            else if (alreadyScreenshotedImage !== null) {
                (0, helper_functions_1.debug)(config.debugMode, 'There was already a screenshot. Updated node ' +
                    node.html +
                    ' with old image_id:' +
                    alreadyScreenshotedImage);
                node.image = alreadyScreenshotedImage;
            }
        }
    }
}
exports.makeScreenshotsWithErrorsBorderd = makeScreenshotsWithErrorsBorderd;
